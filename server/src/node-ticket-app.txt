This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-12-03T23:21:26.052Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
api/ticket/ticket-handlers.ts
api/ticket/ticket-routes.ts
api/ticket/ticket-service.ts
db/index.ts
db/schema/index.ts
db/schema/ticket.ts
db/seed.ts
index.ts
lib/big.ts
middleware/error.ts
middleware/validate.ts
node-ticket-app.txt
utils/async-handler.ts
utils/currency.ts
utils/error.ts

================================================================
Repository Files
================================================================

================
File: api/ticket/ticket-handlers.ts
================
import { Request, Response } from "express";
import * as ticketService from "./ticket-service";
import { insertTicketSchema } from "../../db/schema/ticket";
import { AppError } from "@/utils/error";
import { StatusCodes } from "http-status-codes";

export const getAllTickets = async (_req: Request, res: Response) => {
	const tickets = await ticketService.getAllTickets();
	res.json(tickets);
};

export const getTicketById = async (req: Request, res: Response) => {
	const ticket = await ticketService.getTicketById(req.params.id);
	if (!ticket) {
		throw new AppError(StatusCodes.NOT_FOUND, "Ticket not found");
	}
	res.json(ticket);
};

export const createTicket = async (req: Request, res: Response) => {
	const validatedData = insertTicketSchema.parse(req.body);
	const newTicket = await ticketService.createTicket(validatedData);
	res.status(StatusCodes.CREATED).json(newTicket);
};

export const updateTicket = async (req: Request, res: Response) => {
	const validatedData = insertTicketSchema.partial().parse(req.body);
	const updatedTicket = await ticketService.updateTicket(
		req.params.id,
		validatedData
	);
	if (!updatedTicket) {
		throw new AppError(StatusCodes.NOT_FOUND, "Ticket not found");
	}
	res.json(updatedTicket);
};

export const deleteTicket = async (req: Request, res: Response) => {
	const isDeleted = await ticketService.deleteTicket(req.params.id);
	if (!isDeleted) {
		throw new AppError(StatusCodes.NOT_FOUND, "Ticket not found");
	}
	res.status(StatusCodes.NO_CONTENT).send();
};

================
File: api/ticket/ticket-routes.ts
================
import express from "express";
import * as ticketHandlers from "./ticket-handlers";
import { validateRequest } from "../../middleware/validate";
import { insertTicketSchema } from "../../db/schema/ticket";
import { asyncHandler } from "@/utils/async-handler";

const router = express.Router();

router.get("/", asyncHandler(ticketHandlers.getAllTickets));
router.get("/:id", asyncHandler(ticketHandlers.getTicketById));
router.post(
	"/",
	validateRequest(insertTicketSchema),
	asyncHandler(ticketHandlers.createTicket)
);
router.patch(
	"/:id",
	validateRequest(insertTicketSchema.partial()),
	asyncHandler(ticketHandlers.updateTicket)
);
router.delete("/:id", asyncHandler(ticketHandlers.deleteTicket));

export default router;

================
File: api/ticket/ticket-service.ts
================
import { desc, eq } from "drizzle-orm";
import { db } from "../../db";
import { ticketTable, NewTicket, Ticket } from "../../db/schema/ticket";
import { toCent } from "@/utils/currency";

export const getAllTickets = async (): Promise<Ticket[]> => {
	return await db
		.select()
		.from(ticketTable)
		.orderBy(desc(ticketTable.createdAt));
};

export const getTicketById = async (id: string): Promise<Ticket | null> => {
	const result = await db
		.select()
		.from(ticketTable)
		.where(eq(ticketTable.id, id));
	return result[0] || null;
};

export const createTicket = async (newTicket: NewTicket): Promise<Ticket> => {
	const dbData = {
		...newTicket,
		bounty: toCent(newTicket.bounty),
	};
	const result = await db.insert(ticketTable).values(newTicket).returning();
	return result[0];
};

export const updateTicket = async (
	id: string,
	updateData: Partial<NewTicket>
): Promise<Ticket | null> => {
	const dbData = {
		...updateData,
		bounty: updateData.bounty ? toCent(updateData.bounty) : undefined,
		updatedAt: new Date(),
	};
	const result = await db
		.update(ticketTable)
		.set(updateData)
		.where(eq(ticketTable.id, id))
		.returning();
	return result[0] || null;
};

export const deleteTicket = async (id: string): Promise<boolean> => {
	const result = await db
		.delete(ticketTable)
		.where(eq(ticketTable.id, id))
		.returning();
	return result.length > 0;
};

================
File: db/index.ts
================
import "dotenv/config";
import { drizzle } from "drizzle-orm/node-postgres";
import { Pool } from "pg";
import * as schema from "./schema";
const pool = new Pool({
	connectionString: process.env.DATABASE_URL,
});
export const db = drizzle(pool, { schema });

pool.on("error", (err) => {
	console.error("Unexpected error on idle client", err);
	process.exit(-1);
});

================
File: db/schema/index.ts
================
// export { users } from './users';
// export { posts } from './posts';
export { ticketTable } from "./ticket";

================
File: db/schema/ticket.ts
================
import {
	integer,
	pgEnum,
	pgTable,
	text,
	timestamp,
	uuid,
	varchar,
} from "drizzle-orm/pg-core";
import { createInsertSchema, createSelectSchema } from "drizzle-zod";
import { z } from "zod";

// Définition de l'enum TicketStatus
export const ticketStatus = pgEnum("ticket_status", [
	"OPEN",
	"IN_PROGRESS",
	"DONE",
]);

// Définition de la table ticket
export const ticketTable = pgTable("ticket", {
	//id: text("id").primaryKey().notNull(),
	id: uuid("id").defaultRandom().primaryKey(),
	createdAt: timestamp("created_at").defaultNow().notNull(),
	updatedAt: timestamp("updated_at").defaultNow().notNull(),
	title: text("title").notNull(),
	content: varchar("content", { length: 1024 }).notNull(),
	status: ticketStatus("status").default("OPEN").notNull(),
	deadline: varchar("deadline", { length: 10 }).notNull(), // Length 10 pour format YYYY-MM-DD
	bounty: integer("bounty").notNull(),
});

// Schémas Zod pour la validation
export const selectTicketSchema = createSelectSchema(ticketTable);
export const insertTicketSchema = createInsertSchema(ticketTable, {
	id: z.string().optional(), // Optional car il sera généré automatiquement
	createdAt: z.date().optional(), // Optional car il sera généré automatiquement
	updatedAt: z.date().optional(), // Optional car il sera généré automatiquement
	title: z.string().min(1),
	content: z.string().max(1024),
	status: z.enum(["OPEN", "IN_PROGRESS", "DONE"]).default("OPEN"),
	deadline: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Is required"),
	bounty: z.coerce.number().positive(),
});
export const updateTicketSchema = z.object({
	title: z.string().min(1).optional(),
	content: z.string().max(1024).optional(),
	status: z.enum(["OPEN", "IN_PROGRESS", "DONE"]).optional(),
	deadline: z.string().optional(),
	bounty: z.number().positive().optional(),
});
// Types TypeScript déduits des schémas
export type Ticket = z.infer<typeof selectTicketSchema>;
export type NewTicket = z.infer<typeof insertTicketSchema>;

================
File: db/seed.ts
================
import { db } from "./index";
import { ticketTable } from "./schema";

const tickets = [
	{
		title: "Ticket 1",
		content: "First ticket from DB.",
		status: "DONE" as const,
		//deadline: "2024-12-31",
		deadline: new Date().toISOString().split("T")[0],
		bounty: 499,
	},
	{
		title: "Ticket 2",
		content: "Second ticket from DB.",
		status: "OPEN" as const,
		deadline: new Date().toISOString().split("T")[0],
		bounty: 399,
	},
	{
		title: "Ticket 3",
		content: "Third ticket from DB.",
		status: "IN_PROGRESS" as const,
		deadline: new Date().toISOString().split("T")[0],
		bounty: 599,
	},
];

const seed = async () => {
	const t0 = performance.now();
	console.log("DB Seed: Started ...");

	try {
		// Supprime tous les tickets existants
		await db.delete(ticketTable);

		// Insère les nouveaux tickets
		await db.insert(ticketTable).values(tickets);

		const t1 = performance.now();
		console.log(`DB Seed: Finished (${t1 - t0}ms)`);
	} catch (error) {
		console.error("Error during seeding:", error);
		process.exit(1);
	}
};

seed()
	.then(() => {
		process.exit(0);
	})
	.catch((err) => {
		console.error(err);
		process.exit(1);
	});

================
File: index.ts
================
import express from "express";
import cors from "cors";
import ticketRoutes from "@/api/ticket/ticket-routes";
import { errorHandler } from "./middleware/error";
import { db } from "./db";
import { ticketTable } from "./db/schema/ticket";

const app = express();

app.use(cors());
app.use(express.json());

// Routes
app.use("/api/tickets", ticketRoutes);

// Error handling
app.use(errorHandler);

const PORT = process.env.PORT || 3001;

app.listen(PORT, async () => {
	try {
		await db.select().from(ticketTable).limit(1);
		console.info("✅ Database connected successfully");
		console.info(`Server is running at http://localhost:${PORT}`);
	} catch (error) {
		console.error("❌ Failed to connect to database:", error);
		process.exit(1);
	}
});

export default app;

================
File: lib/big.ts
================
import Big from "big.js";

Big.DP = 2;
Big.RM = Big.roundHalfEven;

export const MyBig = Big;

================
File: middleware/error.ts
================
import { Request, Response, NextFunction } from "express";
import { AppError } from "../utils/error";
import { StatusCodes } from "http-status-codes";

export const errorHandler = (
	err: Error,
	_req: Request,
	res: Response,
	_next: NextFunction
) => {
	if (err instanceof AppError) {
		return res.status(err.statusCode).json({
			status: "error",
			message: err.message,
		});
	}

	console.error("Unhandled error:", err);
	return res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({
		status: "error",
		message: "Internal server error",
	});
};

================
File: middleware/validate.ts
================
import { Request, Response, NextFunction } from "express";
import { ZodSchema } from "zod";
import { AppError } from "../utils/error";
import { StatusCodes } from "http-status-codes";

export const validateRequest = (schema: ZodSchema) => {
	return (req: Request, _res: Response, next: NextFunction) => {
		try {
			schema.parse(req.body);
			next();
		} catch (error) {
			next(new AppError(StatusCodes.UNPROCESSABLE_ENTITY, String(error)));
		}
	};
};

================
File: node-ticket-app.txt
================
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-12-02T07:41:20.848Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
api/ticket/ticket-handlers.ts
api/ticket/ticket-routes.ts
api/ticket/ticket-service.ts
db/index.ts
db/schema/index.ts
db/schema/ticket.ts
db/seed.ts
index.ts
middleware/error.ts
middleware/validate.ts
utils/async-handler.ts
utils/error.ts

================================================================
Repository Files
================================================================

================
File: api/ticket/ticket-handlers.ts
================
import { Request, Response } from "express";
import * as ticketService from "./ticket-service";
import { insertTicketSchema } from "../../db/schema/ticket";
import { AppError } from "@/utils/error";
import { StatusCodes } from "http-status-codes";

export const getAllTickets = async (_req: Request, res: Response) => {
	const tickets = await ticketService.getAllTickets();
	res.json(tickets);
};

export const getTicketById = async (req: Request, res: Response) => {
	const ticket = await ticketService.getTicketById(req.params.id);
	if (!ticket) {
		throw new AppError(StatusCodes.NOT_FOUND, "Ticket not found");
	}
	res.json(ticket);
};

export const createTicket = async (req: Request, res: Response) => {
	const validatedData = insertTicketSchema.parse(req.body);
	const newTicket = await ticketService.createTicket(validatedData);
	res.status(StatusCodes.CREATED).json(newTicket);
};

export const updateTicket = async (req: Request, res: Response) => {
	const validatedData = insertTicketSchema.partial().parse(req.body);
	const updatedTicket = await ticketService.updateTicket(
		req.params.id,
		validatedData
	);
	if (!updatedTicket) {
		throw new AppError(StatusCodes.NOT_FOUND, "Ticket not found");
	}
	res.json(updatedTicket);
};

export const deleteTicket = async (req: Request, res: Response) => {
	const isDeleted = await ticketService.deleteTicket(req.params.id);
	if (!isDeleted) {
		throw new AppError(StatusCodes.NOT_FOUND, "Ticket not found");
	}
	res.status(StatusCodes.NO_CONTENT).send();
};

================
File: api/ticket/ticket-routes.ts
================
import express from "express";
import * as ticketHandlers from "./ticket-handlers";
import { validateRequest } from "../../middleware/validate";
import { insertTicketSchema } from "../../db/schema/ticket";
import { asyncHandler } from "@/utils/async-handler";

const router = express.Router();

router.get("/", asyncHandler(ticketHandlers.getAllTickets));
router.get("/:id", asyncHandler(ticketHandlers.getTicketById));
router.post(
	"/",
	validateRequest(insertTicketSchema),
	asyncHandler(ticketHandlers.createTicket)
);
router.patch(
	"/:id",
	validateRequest(insertTicketSchema.partial()),
	asyncHandler(ticketHandlers.updateTicket)
);
router.delete("/:id", asyncHandler(ticketHandlers.deleteTicket));

export default router;

================
File: api/ticket/ticket-service.ts
================
import { desc, eq } from "drizzle-orm";
import { db } from "../../db";
import { ticketTable, NewTicket, Ticket } from "../../db/schema/ticket";

export const getAllTickets = async (): Promise<Ticket[]> => {
	return await db
		.select()
		.from(ticketTable)
		.orderBy(desc(ticketTable.createdAt));
};

export const getTicketById = async (id: string): Promise<Ticket | null> => {
	const result = await db
		.select()
		.from(ticketTable)
		.where(eq(ticketTable.id, id));
	return result[0] || null;
};

export const createTicket = async (newTicket: NewTicket): Promise<Ticket> => {
	const result = await db.insert(ticketTable).values(newTicket).returning();
	return result[0];
};

export const updateTicket = async (
	id: string,
	updateData: Partial<NewTicket>
): Promise<Ticket | null> => {
	const result = await db
		.update(ticketTable)
		.set({ ...updateData, updatedAt: new Date() })
		.where(eq(ticketTable.id, id))
		.returning();
	return result[0] || null;
};

export const deleteTicket = async (id: string): Promise<boolean> => {
	const result = await db
		.delete(ticketTable)
		.where(eq(ticketTable.id, id))
		.returning();
	return result.length > 0;
};

================
File: db/index.ts
================
import "dotenv/config";
import { drizzle } from "drizzle-orm/node-postgres";
import { Pool } from "pg";
import * as schema from "./schema";
const pool = new Pool({
	connectionString: process.env.DATABASE_URL,
});
export const db = drizzle(pool, { schema });

pool.on("error", (err) => {
	console.error("Unexpected error on idle client", err);
	process.exit(-1);
});

================
File: db/schema/index.ts
================
// export { users } from './users';
// export { posts } from './posts';
export { ticketTable } from "./ticket";

================
File: db/schema/ticket.ts
================
import {
	pgEnum,
	pgTable,
	text,
	timestamp,
	uuid,
	varchar,
} from "drizzle-orm/pg-core";
import { createInsertSchema, createSelectSchema } from "drizzle-zod";
import { z } from "zod";

// Définition de l'enum TicketStatus
export const ticketStatus = pgEnum("ticket_status", [
	"OPEN",
	"IN_PROGRESS",
	"DONE",
]);

// Définition de la table ticket
export const ticketTable = pgTable("ticket", {
	//id: text("id").primaryKey().notNull(),
	id: uuid("id").defaultRandom().primaryKey(),
	createdAt: timestamp("created_at").defaultNow().notNull(),
	updatedAt: timestamp("updated_at").defaultNow().notNull(),
	title: text("title").notNull(),
	content: varchar("content", { length: 1024 }).notNull(),
	status: ticketStatus("status").default("OPEN").notNull(),
});

// Schémas Zod pour la validation
export const selectTicketSchema = createSelectSchema(ticketTable);
export const insertTicketSchema = createInsertSchema(ticketTable, {
	id: z.string().optional(), // Optional car il sera généré automatiquement
	createdAt: z.date().optional(), // Optional car il sera généré automatiquement
	updatedAt: z.date().optional(), // Optional car il sera généré automatiquement
	title: z.string().min(1),
	content: z.string().max(1024),
	status: z.enum(["OPEN", "IN_PROGRESS", "DONE"]).default("OPEN"),
});
export const updateTicketSchema = z.object({
	title: z.string().min(1).optional(),
	content: z.string().max(1024).optional(),
	status: z.enum(["OPEN", "IN_PROGRESS", "DONE"]).optional(),
});
// Types TypeScript déduits des schémas
export type Ticket = z.infer<typeof selectTicketSchema>;
export type NewTicket = z.infer<typeof insertTicketSchema>;

================
File: db/seed.ts
================
import { db } from "./index";
import { ticketTable } from "./schema";

const tickets = [
	{
		title: "Ticket 1",
		content: "First ticket from DB.",
		status: "DONE" as const,
	},
	{
		title: "Ticket 2",
		content: "Second ticket from DB.",
		status: "OPEN" as const,
	},
	{
		title: "Ticket 3",
		content: "Third ticket from DB.",
		status: "IN_PROGRESS" as const,
	},
];

const seed = async () => {
	const t0 = performance.now();
	console.log("DB Seed: Started ...");

	try {
		// Supprime tous les tickets existants
		await db.delete(ticketTable);

		// Insère les nouveaux tickets
		await db.insert(ticketTable).values(tickets);

		const t1 = performance.now();
		console.log(`DB Seed: Finished (${t1 - t0}ms)`);
	} catch (error) {
		console.error("Error during seeding:", error);
		process.exit(1);
	}
};

seed()
	.then(() => {
		process.exit(0);
	})
	.catch((err) => {
		console.error(err);
		process.exit(1);
	});

================
File: index.ts
================
import express from "express";
import cors from "cors";
import ticketRoutes from "@/api/ticket/ticket-routes";
import { errorHandler } from "./middleware/error";
import { db } from "./db";
import { ticketTable } from "./db/schema/ticket";

const app = express();

app.use(cors());
app.use(express.json());

// Routes
app.use("/api/tickets", ticketRoutes);

// Error handling
app.use(errorHandler);

const PORT = process.env.PORT || 3001;

app.listen(PORT, async () => {
	try {
		await db.select().from(ticketTable).limit(1);
		console.info("✅ Database connected successfully");
		console.info(`Server is running at http://localhost:${PORT}`);
	} catch (error) {
		console.error("❌ Failed to connect to database:", error);
		process.exit(1);
	}
});

export default app;

================
File: middleware/error.ts
================
import { Request, Response, NextFunction } from "express";
import { AppError } from "../utils/error";
import { StatusCodes } from "http-status-codes";

export const errorHandler = (
	err: Error,
	_req: Request,
	res: Response,
	_next: NextFunction
) => {
	if (err instanceof AppError) {
		return res.status(err.statusCode).json({
			status: "error",
			message: err.message,
		});
	}

	console.error("Unhandled error:", err);
	return res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({
		status: "error",
		message: "Internal server error",
	});
};

================
File: middleware/validate.ts
================
import { Request, Response, NextFunction } from "express";
import { ZodSchema } from "zod";
import { AppError } from "../utils/error";
import { StatusCodes } from "http-status-codes";

export const validateRequest = (schema: ZodSchema) => {
	return (req: Request, _res: Response, next: NextFunction) => {
		try {
			schema.parse(req.body);
			next();
		} catch (error) {
			next(new AppError(StatusCodes.UNPROCESSABLE_ENTITY, String(error)));
		}
	};
};

================
File: utils/async-handler.ts
================
import { Request, Response, NextFunction } from "express";

type AsyncFunction = (
	req: Request,
	res: Response,
	next: NextFunction
) => Promise<any>;

export const asyncHandler =
	(fn: AsyncFunction) => (req: Request, res: Response, next: NextFunction) => {
		Promise.resolve(fn(req, res, next)).catch(next);
	};

================
File: utils/error.ts
================
export class AppError extends Error {
	constructor(
		public statusCode: number,
		message: string,
		public isOperational = true
	) {
		super(message);
		Error.captureStackTrace(this, this.constructor);
	}
}

================
File: utils/async-handler.ts
================
import { Request, Response, NextFunction } from "express";

type AsyncFunction = (
	req: Request,
	res: Response,
	next: NextFunction
) => Promise<any>;

export const asyncHandler =
	(fn: AsyncFunction) => (req: Request, res: Response, next: NextFunction) => {
		Promise.resolve(fn(req, res, next)).catch(next);
	};

================
File: utils/currency.ts
================
import { MyBig } from "@/lib/big";

export const toCent = (amount: number) =>
	new MyBig(amount).mul(100).round(2).toNumber();

export const fromCent = (amount: number) =>
	new MyBig(amount).div(100).round(2).toNumber();

export const toCurrencyFromCent = (amount: number) =>
	new Intl.NumberFormat("en-US", {
		style: "currency",
		currency: "USD",
	}).format(fromCent(amount));

================
File: utils/error.ts
================
export class AppError extends Error {
	constructor(
		public statusCode: number,
		message: string,
		public isOperational = true
	) {
		super(message);
		Error.captureStackTrace(this, this.constructor);
	}
}
